{"version":3,"sources":["../../src/commands/build-utils.ts"],"names":["checkFolderIsEmpty","path","fs","existsSync","readdirSync","length","checkAndRemoveEmptyDir","publicDir","pagePath","pageHtmlDirectory","dirname","pageDataDirectory","join","removeSync","sortedPageKeysByNestedLevel","pageKeys","sort","a","b","currentPagePathValue","split","previousPagePathValue","removePageFiles","removePages","map","removePromise","then","store","dispatch","type","payload","removePageDataList","Promise","all","forEach","calcDirtyHtmlFiles","state","toRegenerate","toDelete","html","unsafeBuiltinWasUsedInSSR","reporter","warn","trackedHtmlFiles","htmlFile","isDeleted","pages","has","push","dirty","markHtmlDirtyIfResultOfUsedStaticQueryChanged","getState","dirtyStaticQueryResults","Set","trackedStaticQueryResults","staticQueryResultState","staticQueryHash","add","dirtyTemplates","staticQueriesByTemplate","staticQueryHashes","componentPath","dirtyStaticQueryHash","includes","dirtyPages","dirtyTemplate","component","components","get","page"],"mappings":"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","sourcesContent":["import fs from \"fs-extra\"\nimport path from \"path\"\n\nimport reporter from \"gatsby-cli/lib/reporter\"\n\nimport {\n  remove as removePageHtmlFile,\n  getPageHtmlFilePath,\n} from \"../utils/page-html\"\nimport { removePageData, fixedPagePath } from \"../utils/page-data\"\nimport { store } from \"../redux\"\nimport { IGatsbyState } from \"../redux/types\"\n\nconst checkFolderIsEmpty = (path: string): boolean =>\n  fs.existsSync(path) && !fs.readdirSync(path).length\n\nconst checkAndRemoveEmptyDir = (publicDir: string, pagePath: string): void => {\n  const pageHtmlDirectory = path.dirname(\n    getPageHtmlFilePath(publicDir, pagePath)\n  )\n  const pageDataDirectory = path.join(\n    publicDir,\n    `page-data`,\n    fixedPagePath(pagePath)\n  )\n  // if page's folder is empty also remove matching page-data folder\n  if (checkFolderIsEmpty(pageHtmlDirectory)) {\n    fs.removeSync(pageHtmlDirectory)\n  }\n  if (checkFolderIsEmpty(pageDataDirectory)) {\n    fs.removeSync(pageDataDirectory)\n  }\n}\n\nconst sortedPageKeysByNestedLevel = (pageKeys: Array<string>): Array<string> =>\n  pageKeys.sort((a, b) => {\n    const currentPagePathValue = a.split(`/`).length\n    const previousPagePathValue = b.split(`/`).length\n    return previousPagePathValue - currentPagePathValue\n  })\n\nexport const removePageFiles = async (\n  publicDir: string,\n  pageKeys: Array<string>\n): Promise<void> => {\n  const removePages = pageKeys.map(pagePath => {\n    const removePromise = removePageHtmlFile({ publicDir }, pagePath)\n    removePromise.then(() => {\n      store.dispatch({\n        type: `HTML_REMOVED`,\n        payload: pagePath,\n      })\n    })\n    return removePromise\n  })\n\n  const removePageDataList = pageKeys.map(pagePath =>\n    removePageData(publicDir, pagePath)\n  )\n\n  return Promise.all([...removePages, ...removePageDataList]).then(() => {\n    // Sort removed pageKeys by nested directories and remove if empty.\n    sortedPageKeysByNestedLevel(pageKeys).forEach(pagePath => {\n      checkAndRemoveEmptyDir(publicDir, pagePath)\n    })\n  })\n}\n\nexport function calcDirtyHtmlFiles(\n  state: IGatsbyState\n): { toRegenerate: Array<string>; toDelete: Array<string> } {\n  const toRegenerate: Array<string> = []\n  const toDelete: Array<string> = []\n\n  if (state.html.unsafeBuiltinWasUsedInSSR) {\n    reporter.warn(\n      `Previous build used unsafe builtin method. We need to rebuild all pages`\n    )\n  }\n\n  state.html.trackedHtmlFiles.forEach(function (htmlFile, path) {\n    if (htmlFile.isDeleted || !state.pages.has(path)) {\n      // FIXME: checking pages state here because pages are not persisted\n      // and because of that `isDeleted` might not be set ...\n      toDelete.push(path)\n    } else if (htmlFile.dirty || state.html.unsafeBuiltinWasUsedInSSR) {\n      toRegenerate.push(path)\n    }\n  })\n\n  return {\n    toRegenerate,\n    toDelete,\n  }\n}\n\nexport function markHtmlDirtyIfResultOfUsedStaticQueryChanged(): void {\n  const state = store.getState()\n\n  const dirtyStaticQueryResults = new Set<string>()\n  state.html.trackedStaticQueryResults.forEach(function (\n    staticQueryResultState,\n    staticQueryHash\n  ) {\n    if (staticQueryResultState.dirty) {\n      dirtyStaticQueryResults.add(staticQueryHash)\n    }\n  })\n\n  // we have dirty static query hashes - now we need to find templates that use them\n  const dirtyTemplates = new Set<string>()\n  state.staticQueriesByTemplate.forEach(function (\n    staticQueryHashes,\n    componentPath\n  ) {\n    for (const dirtyStaticQueryHash of dirtyStaticQueryResults) {\n      if (staticQueryHashes.includes(dirtyStaticQueryHash)) {\n        dirtyTemplates.add(componentPath)\n        break // we already know this template need to rebuild, no need to check rest of queries\n      }\n    }\n  })\n\n  // mark html as dirty\n  const dirtyPages = new Set<string>()\n  for (const dirtyTemplate of dirtyTemplates) {\n    const component = state.components.get(dirtyTemplate)\n    if (component) {\n      for (const page of component.pages) {\n        dirtyPages.add(page)\n      }\n    }\n  }\n\n  store.dispatch({\n    type: `HTML_MARK_DIRTY_BECAUSE_STATIC_QUERY_RESULT_CHANGED`,\n    payload: {\n      pages: dirtyPages,\n      staticQueryHashes: dirtyStaticQueryResults,\n    },\n  })\n}\n"],"file":"build-utils.js"}