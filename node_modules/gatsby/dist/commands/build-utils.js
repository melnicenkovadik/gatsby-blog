"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.calcDirtyHtmlFiles = calcDirtyHtmlFiles;
exports.markHtmlDirtyIfResultOfUsedStaticQueryChanged = markHtmlDirtyIfResultOfUsedStaticQueryChanged;
exports.removePageFiles = void 0;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _pageHtml = require("../utils/page-html");

var _pageData = require("../utils/page-data");

var _redux = require("../redux");

const checkFolderIsEmpty = path => _fsExtra.default.existsSync(path) && !_fsExtra.default.readdirSync(path).length;

const checkAndRemoveEmptyDir = (publicDir, pagePath) => {
  const pageHtmlDirectory = _path.default.dirname((0, _pageHtml.getPageHtmlFilePath)(publicDir, pagePath));

  const pageDataDirectory = _path.default.join(publicDir, `page-data`, (0, _pageData.fixedPagePath)(pagePath)); // if page's folder is empty also remove matching page-data folder


  if (checkFolderIsEmpty(pageHtmlDirectory)) {
    _fsExtra.default.removeSync(pageHtmlDirectory);
  }

  if (checkFolderIsEmpty(pageDataDirectory)) {
    _fsExtra.default.removeSync(pageDataDirectory);
  }
};

const sortedPageKeysByNestedLevel = pageKeys => pageKeys.sort((a, b) => {
  const currentPagePathValue = a.split(`/`).length;
  const previousPagePathValue = b.split(`/`).length;
  return previousPagePathValue - currentPagePathValue;
});

const removePageFiles = async (publicDir, pageKeys) => {
  const removePages = pageKeys.map(pagePath => {
    const removePromise = (0, _pageHtml.remove)({
      publicDir
    }, pagePath);
    removePromise.then(() => {
      _redux.store.dispatch({
        type: `HTML_REMOVED`,
        payload: pagePath
      });
    });
    return removePromise;
  });
  const removePageDataList = pageKeys.map(pagePath => (0, _pageData.removePageData)(publicDir, pagePath));
  return Promise.all([...removePages, ...removePageDataList]).then(() => {
    // Sort removed pageKeys by nested directories and remove if empty.
    sortedPageKeysByNestedLevel(pageKeys).forEach(pagePath => {
      checkAndRemoveEmptyDir(publicDir, pagePath);
    });
  });
};

exports.removePageFiles = removePageFiles;

function calcDirtyHtmlFiles(state) {
  const toRegenerate = [];
  const toDelete = [];

  if (state.html.unsafeBuiltinWasUsedInSSR) {
    _reporter.default.warn(`Previous build used unsafe builtin method. We need to rebuild all pages`);
  }

  state.html.trackedHtmlFiles.forEach(function (htmlFile, path) {
    if (htmlFile.isDeleted || !state.pages.has(path)) {
      // FIXME: checking pages state here because pages are not persisted
      // and because of that `isDeleted` might not be set ...
      toDelete.push(path);
    } else if (htmlFile.dirty || state.html.unsafeBuiltinWasUsedInSSR) {
      toRegenerate.push(path);
    }
  });
  return {
    toRegenerate,
    toDelete
  };
}

function markHtmlDirtyIfResultOfUsedStaticQueryChanged() {
  const state = _redux.store.getState();

  const dirtyStaticQueryResults = new Set();
  state.html.trackedStaticQueryResults.forEach(function (staticQueryResultState, staticQueryHash) {
    if (staticQueryResultState.dirty) {
      dirtyStaticQueryResults.add(staticQueryHash);
    }
  }); // we have dirty static query hashes - now we need to find templates that use them

  const dirtyTemplates = new Set();
  state.staticQueriesByTemplate.forEach(function (staticQueryHashes, componentPath) {
    for (const dirtyStaticQueryHash of dirtyStaticQueryResults) {
      if (staticQueryHashes.includes(dirtyStaticQueryHash)) {
        dirtyTemplates.add(componentPath);
        break; // we already know this template need to rebuild, no need to check rest of queries
      }
    }
  }); // mark html as dirty

  const dirtyPages = new Set();

  for (const dirtyTemplate of dirtyTemplates) {
    const component = state.components.get(dirtyTemplate);

    if (component) {
      for (const page of component.pages) {
        dirtyPages.add(page);
      }
    }
  }

  _redux.store.dispatch({
    type: `HTML_MARK_DIRTY_BECAUSE_STATIC_QUERY_RESULT_CHANGED`,
    payload: {
      pages: dirtyPages,
      staticQueryHashes: dirtyStaticQueryResults
    }
  });
}
//# sourceMappingURL=build-utils.js.map